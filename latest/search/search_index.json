{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Transparency Simulation Core","text":"<p>A foundational toolkit for generating synthetic transparency data and calculating metrics for research and education.</p>"},{"location":"#overview","title":"Overview","text":"<p>This package provides the essential building blocks for transparency research without revealing detection methods or assessment criteria. It enables researchers to generate controlled datasets, calculate standard metrics, and build reproducible analysis pipelines.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>Standardized Data Types: Core structures for temporal events, content fingerprints, and aggregated metrics that enable reproducible transparency research across different research groups.</p> <p>Synthetic Data Generation: Create realistic datasets with organic activity patterns, content clustering, and temporal dynamics. Generate both baseline and influenced scenarios for A/B comparisons.</p> <p>Standard Metrics: Calculate transparency metrics including duplicate rates, hash concentration (Herfindahl index), burst detection, and content type distributions.</p> <p>Database Integration: Export data to JSONL format and load into DuckDB for SQL-based analysis and visualization.</p> <p>Cross-Platform CLI: Simple command-line interface for data generation and conversion workflows.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install the package:</p> <pre><code>pip install civic-transparency-sim\n</code></pre> <p>Generate synthetic data:</p> <pre><code>ct-sdk generate --world A --topic-id baseline --out world_A.jsonl\nct-sdk convert --jsonl world_A.jsonl --duck world_A.duckdb --schema schema/schema.sql\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Academic Research: Generate controlled datasets for studying information dynamics</li> <li>Education: Provide realistic data for analysis exercises and metric calculation practice  </li> <li>Algorithm Development: Create test datasets with known ground truth for developing transparency tools</li> <li>Benchmarking: Standard metrics and data formats enable comparison across research groups</li> </ul>"},{"location":"#security-model","title":"Security Model","text":"<p>This package provides building blocks for transparency research without revealing: - Detection algorithms or thresholds - Verification workflows or assessment criteria - Specific patterns that trigger alerts</p> <p>Detection logic and verification tools are maintained separately to prevent adversarial use while enabling legitimate research.</p>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>Civic Transparency Spec - API specifications and standards</li> <li>Civic Transparency Types - Core type definitions and schemas</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The <code>ct-sdk</code> command-line interface provides simple workflows for data generation and conversion.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>After installing the package, the CLI is available as <code>ct-sdk</code>:</p> <pre><code>pip install civic-transparency-sim\nct-sdk --help\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#generate","title":"generate","text":"<p>Generate synthetic transparency data.</p> <pre><code>ct-sdk generate [OPTIONS]\n</code></pre> <p>Required Arguments: - <code>--world TEXT</code>: World identifier (e.g., \"A\", \"B\", \"baseline\") - <code>--topic-id TEXT</code>: Topic identifier for content clustering - <code>--out TEXT</code>: Output JSONL file path</p> <p>Optional Arguments: - <code>--windows INTEGER</code>: Number of time windows [default: 12] - <code>--step-minutes INTEGER</code>: Minutes per window [default: 10] - <code>--seed INTEGER</code>: Random seed for reproducibility [default: 4242]</p> <p>Influence Parameters (optional): - <code>--dup-mult FLOAT</code>: Duplicate multiplier for amplified content sharing - <code>--burst-minutes INTEGER</code>: Micro-burst duration for coordinated activity - <code>--reply-nudge FLOAT</code>: Reply proportion adjustment (+/- shift)</p> <p>Examples:</p> <p>Baseline organic generation:</p> <pre><code>ct-sdk generate --world A --topic-id baseline --out world_A.jsonl\n</code></pre> <p>Influenced generation:</p> <pre><code>ct-sdk generate --world B --topic-id influenced --out world_B.jsonl \\\n  --seed 4343 --dup-mult 1.35 --burst-minutes 3 --reply-nudge -0.10\n</code></pre> <p>Behavior: When any influence parameters are provided, the system automatically switches to influenced generation mode. Without influence parameters, it generates baseline organic patterns.</p>"},{"location":"cli/#convert","title":"convert","text":"<p>Convert JSONL data to DuckDB format for analysis.</p> <pre><code>ct-sdk convert [OPTIONS]\n</code></pre> <p>Required Arguments: - <code>--jsonl TEXT</code>: Input JSONL file path - <code>--duck TEXT</code>: Output DuckDB file path - <code>--schema TEXT</code>: Schema SQL file path</p> <p>Example:</p> <pre><code>ct-sdk convert --jsonl world_A.jsonl --duck world_A.duckdb --schema schema/schema.sql\n</code></pre> <p>Behavior: - Creates the database file if it doesn't exist - Creates the events table using the provided schema - Clears existing data and loads new records - Reports the number of rows loaded</p>"},{"location":"cli/#advanced-usage","title":"Advanced Usage","text":""},{"location":"cli/#direct-script-access","title":"Direct Script Access","text":"<p>For advanced users who need more control, the underlying scripts can be called directly:</p> <pre><code># Direct generation with all parameters\npython -m scripts_py.gen_empty_world --world A --topic-id baseline --out world_A.jsonl\n\n# Influenced generation with full parameter control\npython -m scripts_py.gen_world_b_light --topic-id influenced --out world_B.jsonl \\\n  --windows 12 --step-minutes 10 --seed 4343 --dup-mult 1.35 --burst-minutes 3 --reply-nudge -0.10\n\n# Database conversion with mode options\npython -m scripts_py.jsonl_to_duckdb --jsonl world_A.jsonl --duck world_A.duckdb --schema schema/schema.sql\n\n# Analysis and plotting\npython -m scripts_py.plot_quick --duck world_A.duckdb --outdir plots/world_A\npython -m scripts_py.plot_compare_ducks --ducks world_A.duckdb world_B.duckdb --outdir plots/compare_AB\n</code></pre>"},{"location":"cli/#typical-workflow","title":"Typical Workflow","text":"<ol> <li> <p>Generate baseline data:    <code>bash    ct-sdk generate --world A --topic-id baseline --out world_A.jsonl</code></p> </li> <li> <p>Generate comparison data:    <code>bash    ct-sdk generate --world B --topic-id influenced --out world_B.jsonl --dup-mult 1.35</code></p> </li> <li> <p>Convert to databases:    <code>bash    ct-sdk convert --jsonl world_A.jsonl --duck world_A.duckdb --schema schema/schema.sql    ct-sdk convert --jsonl world_B.jsonl --duck world_B.duckdb --schema schema/schema.sql</code></p> </li> <li> <p>Analyze with external tools or direct script access for plotting.</p> </li> </ol>"},{"location":"cli/#error-handling","title":"Error Handling","text":"<p>The CLI provides clear error messages for common issues: - Missing required arguments - File not found errors - Invalid parameter values - Schema application failures</p> <p>All errors include context and suggested fixes where possible.</p>"},{"location":"schema/","title":"Schema Reference","text":"<p>This document describes the database schema used for storing transparency simulation data in DuckDB.</p>"},{"location":"schema/#privacy","title":"Privacy","text":"<p>This schema stores only <code>aggregated metrics</code> and <code>hash-based identifiers</code>. Hashes are one-way digests and cannot be reversed to original content. No raw user data or message text is recorded.</p>"},{"location":"schema/#events-table","title":"Events Table","text":"<p>The primary table <code>events</code> stores window-level aggregations of activity data.</p>"},{"location":"schema/#schema-definition","title":"Schema Definition","text":"<pre><code>CREATE TABLE events (\n    world_id TEXT,\n    topic_id TEXT,\n    window_start TIMESTAMP,\n    window_end TIMESTAMP,\n    n_messages INTEGER,\n    n_unique_hashes INTEGER,\n    dup_rate REAL,\n    top_hashes TEXT,  -- JSON array\n    hash_concentration REAL,\n    burst_score REAL,\n    type_post REAL,\n    type_reply REAL,\n    type_retweet REAL,\n    time_histogram TEXT  -- JSON array\n);\n</code></pre>"},{"location":"schema/#column-descriptions","title":"Column Descriptions","text":"<p>Identifiers: - <code>world_id</code>: World identifier (e.g., \"A\", \"B\") - <code>topic_id</code>: Topic/content cluster identifier</p> <p>Temporal: - <code>window_start</code>: Window start timestamp (ISO format) - <code>window_end</code>: Window end timestamp (ISO format)</p> <p>Activity Metrics: - <code>n_messages</code>: Total messages in window - <code>n_unique_hashes</code>: Number of unique content hashes - <code>dup_rate</code>: Duplication rate (0.0 to 1.0)</p> <p>Content Analysis: - <code>top_hashes</code>: JSON array of top content clusters with counts - <code>hash_concentration</code>: Herfindahl index of hash distribution</p> <p>Temporal Patterns: - <code>burst_score</code>: Coefficient of variation for minute-level activity - <code>time_histogram</code>: JSON array of message counts per minute</p> <p>Content Types: - <code>type_post</code>: Proportion of original posts (0.0 to 1.0) - <code>type_reply</code>: Proportion of replies (0.0 to 1.0) - <code>type_retweet</code>: Proportion of retweets/shares (0.0 to 1.0)</p>"},{"location":"schema/#json-column-formats","title":"JSON Column Formats","text":"<p>top_hashes contains an array of objects:</p> <pre><code>[\n  {\n    \"hash\": {\n      \"id\": {\n        \"algo\": \"opaque\",\n        \"value\": \"h1\"\n      }\n    },\n    \"count\": 8\n  }\n]\n</code></pre> <p>time_histogram contains minute-level counts:</p> <pre><code>[12, 9, 7, 5, 3, 2, 1, 0, 0, 0]\n</code></pre>"},{"location":"schema/#schema-variants","title":"Schema Variants","text":""},{"location":"schema/#student-schema-schemasql","title":"Student Schema (<code>schema.sql</code>)","text":"<p>Basic schema for educational use with essential columns and clear documentation.</p>"},{"location":"schema/#loading-data","title":"Loading Data","text":"<p>Data is loaded via the conversion utility:</p> <pre><code>ct-sdk convert --jsonl data.jsonl --duck data.duckdb --schema schema/schema.sql\n</code></pre> <p>The loader: 1. Creates the table if it doesn't exist 2. Clears existing data 3. Inserts new records with proper type conversion 4. Validates JSON column formats</p>"},{"location":"schema/#query-examples","title":"Query Examples","text":"<p>Basic aggregations:</p> <pre><code>SELECT \n    world_id,\n    AVG(dup_rate) as avg_dup_rate,\n    AVG(hash_concentration) as avg_concentration,\n    AVG(burst_score) as avg_burst_score\nFROM events \nGROUP BY world_id;\n</code></pre> <p>Time series analysis:</p> <pre><code>SELECT \n    window_start,\n    n_messages,\n    dup_rate,\n    burst_score\nFROM events \nWHERE world_id = 'A'\nORDER BY window_start;\n</code></pre> <p>Content type analysis:</p> <pre><code>SELECT \n    world_id,\n    AVG(type_post) as avg_post_share,\n    AVG(type_reply) as avg_reply_share,\n    AVG(type_retweet) as avg_retweet_share\nFROM events \nGROUP BY world_id;\n</code></pre> <p>JSON data extraction:</p> <pre><code>-- Extract top hash information (DuckDB JSON functions)\nSELECT \n    world_id,\n    topic_id,\n    json_extract_string(top_hashes, '$[0].hash.id.value') as top_hash_id,\n    json_extract(top_hashes, '$[0].count') as top_hash_count\nFROM events;\n</code></pre>"},{"location":"schema/#data-types-and-constraints","title":"Data Types and Constraints","text":"<p>Timestamps: Stored as TIMESTAMP, typically UTC Rates: REAL values between 0.0 and 1.0 Counts: Non-negative INTEGER values JSON: Valid JSON strings for complex data Identifiers: TEXT with application-specific formats</p>"},{"location":"schema/#performance-considerations","title":"Performance Considerations","text":"<p>Indexing: Consider indexes on <code>world_id</code>, <code>topic_id</code>, and <code>window_start</code> for common queries.</p> <p>JSON Processing: DuckDB provides efficient JSON functions for extracting specific fields from JSON columns.</p> <p>Time Series: Window-based partitioning can improve performance for time series queries.</p> <p>Aggregations: Pre-computed aggregations are stored at the window level to optimize analysis queries.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide covers the basic workflows for generating synthetic transparency data and converting it for analysis.</p>"},{"location":"usage/#installation","title":"Installation","text":"<pre><code>pip install civic-transparency-sim\n</code></pre>"},{"location":"usage/#basic-workflow","title":"Basic Workflow","text":""},{"location":"usage/#1-generate-synthetic-data","title":"1. Generate Synthetic Data","text":"<p>Baseline (Organic) World:</p> <pre><code>ct-sdk generate --world A --topic-id baseline --out world_A.jsonl\n</code></pre> <p>Influenced World with Parameters:</p> <pre><code>ct-sdk generate --world B --topic-id influenced --out world_B.jsonl \\\n  --seed 4343 --dup-mult 1.35 --burst-minutes 3 --reply-nudge -0.10\n</code></pre>"},{"location":"usage/#2-convert-to-database","title":"2. Convert to Database","text":"<pre><code>ct-sdk convert --jsonl world_A.jsonl --duck world_A.duckdb --schema schema/schema.sql\nct-sdk convert --jsonl world_B.jsonl --duck world_B.duckdb --schema schema/schema.sql\n</code></pre>"},{"location":"usage/#3-analyze-with-direct-scripts","title":"3. Analyze with Direct Scripts","text":"<pre><code># Individual world analysis\npython -m scripts_py.plot_quick --duck world_A.duckdb --outdir plots/world_A\n\n# Comparative analysis  \npython -m scripts_py.plot_compare_ducks --ducks world_A.duckdb world_B.duckdb --outdir plots/compare_AB\n</code></pre>"},{"location":"usage/#generation-parameters","title":"Generation Parameters","text":""},{"location":"usage/#core-parameters","title":"Core Parameters","text":"<ul> <li><code>--world</code>: World identifier (e.g., \"A\", \"B\", \"baseline\")</li> <li><code>--topic-id</code>: Topic identifier for content clustering  </li> <li><code>--out</code>: Output JSONL file path</li> <li><code>--windows</code>: Number of time windows (default: 12)</li> <li><code>--step-minutes</code>: Minutes per window (default: 10)</li> <li><code>--seed</code>: Random seed for reproducibility (default: 4242)</li> </ul>"},{"location":"usage/#influence-parameters","title":"Influence Parameters","text":"<p>Optional parameters that modify generation behavior:</p> <ul> <li><code>--dup-mult</code>: Duplicate multiplier (amplifies content duplication)</li> <li><code>--burst-minutes</code>: Micro-burst duration (coordinated activity spikes)</li> <li><code>--reply-nudge</code>: Reply proportion adjustment (positive/negative shift)</li> </ul> <p>When any influence parameters are provided, the system automatically uses the influenced generation algorithm.</p>"},{"location":"usage/#data-format","title":"Data Format","text":"<p>Generated JSONL files contain window aggregation records with:</p> <ul> <li>Temporal data: Window start/end times</li> <li>Activity metrics: Message counts, unique hashes, duplicate rates</li> <li>Content fingerprints: SimHash and MinHash signatures</li> <li>Clustering data: Top hash frequencies, concentration measures</li> <li>Behavioral patterns: Type mix (post/reply/retweet), burst scores</li> </ul>"},{"location":"usage/#database-schema","title":"Database Schema","text":"<p>The DuckDB schema includes:</p> <ul> <li>Primary table: <code>events</code> with window-level aggregations</li> <li>Columns for all core metrics and metadata</li> <li>JSON columns for complex data (top_hashes, time_histogram)</li> <li>Proper typing for timestamps and numeric values</li> </ul>"},{"location":"usage/#reproducibility","title":"Reproducibility","text":"<p>All generation is deterministic:</p> <ul> <li>Seed-based: Same seed produces identical output</li> <li>Version tracking: Metadata includes package versions</li> <li>Parameter logging: All settings preserved in output</li> <li>Schema versioning: Database structures documented</li> </ul>"},{"location":"usage/#example-seeds","title":"Example Seeds","text":"<p>Standard seeds for common scenarios:</p> <ul> <li>Baseline organic: <code>4242</code></li> <li>Light influence: <code>4343</code></li> <li>Custom scenarios: Use any integer</li> </ul>"},{"location":"usage/#programmatic-usage","title":"Programmatic Usage","text":"<pre><code>from ci.transparency.sdk import WindowAgg\nfrom ci.transparency.sim.metrics import herfindahl, cv_of_bins\n\n# Load and analyze data programmatically\n# (See Type Reference for detailed API documentation)\n</code></pre>"},{"location":"sdk/digests/","title":"Content Digests","text":"<p>Content digests provide fingerprinting data structures for content analysis and research.</p>"},{"location":"sdk/digests/#overview","title":"Overview","text":"<p>Digest types implement content fingerprinting that can be used in transparency research. These data structures store signature information without implementing analysis algorithms.</p>"},{"location":"sdk/digests/#core-types","title":"Core Types","text":""},{"location":"sdk/digests/#simhash64","title":"SimHash64","text":"<p>64-bit SimHash signature storage.</p> <pre><code>@dataclass(frozen=True)\nclass SimHash64:\n    bits: int\n</code></pre> <p>Fields: - bits: 64-bit integer representing the SimHash signature</p> <p>Usage:</p> <pre><code>from ci.transparency.sdk import SimHash64\n\n# Create SimHash\nsim_hash = SimHash64(bits=0x9F3A5C10AA55EE77)\n</code></pre>"},{"location":"sdk/digests/#minhashsig","title":"MinHashSig","text":"<p>MinHash signature for set-based fingerprinting.</p> <pre><code>@dataclass(frozen=True)\nclass MinHashSig:\n    k: int\n    sig: Tuple[int, ...]\n</code></pre> <p>Fields: - k: Signature size (number of hash functions) - sig: Tuple of k hash values</p> <p>Usage:</p> <pre><code>from ci.transparency.sdk import MinHashSig\n\n# Create MinHash signature\nmin_hash = MinHashSig(k=4, sig=(0x1, 0x2, 0x3, 0x4))\n</code></pre>"},{"location":"sdk/digests/#digests","title":"Digests","text":"<p>Container for multiple digest types.</p> <pre><code>@dataclass(frozen=True)\nclass Digests:\n    simhash64: Optional[SimHash64] = None\n    minhash: Optional[MinHashSig] = None\n</code></pre> <p>Usage:</p> <pre><code>from ci.transparency.sdk import Digests, SimHash64, MinHashSig\n\ndigests = Digests(\n    simhash64=SimHash64(bits=0x9F3A5C10AA55EE77),\n    minhash=MinHashSig(k=4, sig=(0x1, 0x2, 0x3, 0x4))\n)\n</code></pre>"},{"location":"sdk/digests/#algorithms","title":"Algorithms","text":""},{"location":"sdk/digests/#simhash","title":"SimHash","text":"<p>SimHash creates fingerprints for content:</p> <ul> <li>Storage Format: 64-bit integer representation</li> <li>Applications: Content fingerprinting and data analysis</li> </ul>"},{"location":"sdk/digests/#minhash","title":"MinHash","text":"<p>MinHash provides signature-based fingerprinting:</p> <ul> <li>Signature Format: Tuple of k integers</li> <li>Applications: Set-based content analysis</li> </ul>"},{"location":"sdk/digests/#usage-patterns","title":"Usage Patterns","text":""},{"location":"sdk/digests/#basic-data-creation","title":"Basic Data Creation","text":"<pre><code># Create content fingerprints\ncontent_digest = Digests(\n    simhash64=SimHash64(bits=computed_simhash_value),\n    minhash=MinHashSig(k=128, sig=computed_minhash_signature)\n)\n</code></pre>"},{"location":"sdk/digests/#data-access","title":"Data Access","text":"<pre><code># Access digest components\nif digests.simhash64:\n    bits_value = digests.simhash64.bits\n\nif digests.minhash:\n    signature_size = digests.minhash.k\n    signature_data = digests.minhash.sig\n</code></pre>"},{"location":"sdk/digests/#performance-considerations","title":"Performance Considerations","text":""},{"location":"sdk/digests/#simhash_1","title":"SimHash","text":"<ul> <li>Memory Efficient: 64-bit storage regardless of content size</li> <li>Simple Structure: Direct integer storage</li> </ul>"},{"location":"sdk/digests/#minhash_1","title":"MinHash","text":"<ul> <li>Configurable Size: k parameter controls signature length</li> <li>Tuple Storage: Immutable sequence of integers</li> </ul>"},{"location":"sdk/digests/#serialization","title":"Serialization","text":"<p>Digests serialize to structured JSON:</p> <pre><code>{\n  \"simhash64\": {\n    \"bits\": \"0x9F3A5C10AA55EE77\"\n  },\n  \"minhash\": {\n    \"k\": 4,\n    \"sig\": [1, 2, 3, 4]\n  }\n}\n</code></pre>"},{"location":"sdk/digests/#related-types","title":"Related Types","text":"<ul> <li>WindowAgg - Contains optional digest data</li> <li>ContentHash - Content identification</li> <li>I/O Schema - Serialization utilities</li> </ul>"},{"location":"sdk/digests/#database-storage","title":"Database Storage","text":"<p>Digest data is stored as JSON in database fields: - Compact representation preserves all signature data - Optional fields support partial fingerprinting - JSON format enables flexible querying</p> <p>See Schema Reference for storage details.</p>"},{"location":"sdk/hash_core/","title":"Content Hashing","text":"<p>Content hashing types provide structures for content identification without requiring access to raw content.</p>"},{"location":"sdk/hash_core/#overview","title":"Overview","text":"<p>The hash core defines types for representing content via identifiers and fingerprints. This supports privacy-preserving analysis and interoperable APIs.</p>"},{"location":"sdk/hash_core/#core-types","title":"Core Types","text":""},{"location":"sdk/hash_core/#hashid-hashid","title":"HashId {#hashid}","text":"<p>Represents a typed, canonical content identifier.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass HashId:\n    algo: str   # e.g., \"sha256\", \"blake3\", \"opaque\", \"simhash64\"\n    value: str  # canonical string for that algo (e.g., lowercase hex)\n</code></pre> <p>Fields: - algo: Hash algorithm type (e.g., \"sha256\", \"opaque\", \"simhash\") - value: Canonicalized hash value (e.g., lowercase hex; simhash64 is 16 hex chars, no 0x).</p> <p>Usage:</p> <pre><code>from ci.transparency.sdk import HashId\n\n# Opaque identifier (privacy-preserving)\nhash_id = HashId(\"opaque\", \"h1\")\n\n# Cryptographic hash (lowercase hex)\ncrypto_hash = HashId(\"sha256\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\")\n\n# Similarity hash (64-bit, 16 hex chars)\nsim64 = HashId(\"simhash64\", \"9f3a5c10aa55ee77\")\n</code></pre> <p>Note: Multi-value fingerprints like MinHash are not represented as HashId.  They live in Digests.</p>"},{"location":"sdk/hash_core/#contenthash-contenthash","title":"ContentHash {#contenthash}","text":"<p>Wrapper for a <code>HashId</code>.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass ContentHash:\n    id: HashId\n</code></pre> <p>Usage:</p> <pre><code>from ci.transparency.sdk import ContentHash, HashId\n\ncontent = ContentHash(HashId(\"opaque\", \"content_123\"))\n</code></pre>"},{"location":"sdk/hash_core/#tophash-tophash","title":"TopHash {#tophash}","text":"<p>Represents a content item (by <code>ContentHash</code>) with its frequency.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass TopHash:\n    hash: ContentHash\n    count: int\n</code></pre> <p>Fields: - hash: Content identifier - count: Frequency of this item in the dataset/window</p> <p>Usage:</p> <pre><code>from ci.transparency.sdk.types import TopHash, ContentHash, HashId\n\ntop_content = TopHash(\n    hash=ContentHash(HashId(\"opaque\", \"popular_content\")),\n    count=42\n)\n</code></pre>"},{"location":"sdk/hash_core/#design-principles","title":"Design Principles","text":""},{"location":"sdk/hash_core/#privacy-first","title":"Privacy-First","text":"<p>Content is represented by hashes and cluster keys, not raw text.</p>"},{"location":"sdk/hash_core/#type-safety","title":"Type Safety","text":"<p>Algorithms are explicitly labeled via <code>algo</code> to prevent mixing types.</p>"},{"location":"sdk/hash_core/#frequency-tracking","title":"Frequency Tracking","text":"<p><code>TopHash</code> couples a content identifier with counts for aggregation.</p>"},{"location":"sdk/hash_core/#hash-types","title":"Hash Types","text":""},{"location":"sdk/hash_core/#opaque-hashes","title":"Opaque Hashes","text":"<p>Synthetic/testing identifiers (no content required):</p> <pre><code>HashId(\"opaque\", \"h1\")\nHashId(\"opaque\", \"test_content_abc\")\n</code></pre>"},{"location":"sdk/hash_core/#cryptographic-hashes","title":"Cryptographic Hashes","text":"<p>Standard one-way hashes:</p> <pre><code>HashId(\"sha256\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\")\nHashId(\"md5\", \"d41d8cd98f00b204e9800998ecf8427e\")\n</code></pre>"},{"location":"sdk/hash_core/#similarity-hashes","title":"Similarity Hashes","text":"<p>Locality-sensitive single-value identifiers (64-bit SimHash):</p> <pre><code>HashId(\"simhash\", \"9f3a5c10aa55ee77\")\n</code></pre> <p>For MinHash (multi-value), see Digests.</p>"},{"location":"sdk/hash_core/#usage-patterns","title":"Usage Patterns","text":""},{"location":"sdk/hash_core/#content-identification","title":"Content Identification","text":"<pre><code># Build a map from content id -&gt; count\ncontent_map = {}\nfor top in window.top_hashes:\n    content_map[top.hash.id.value] = top.count\n</code></pre>"},{"location":"sdk/hash_core/#data-structure-creation","title":"Data Structure Creation","text":"<pre><code>from ci.transparency.sdk.types import TopHash, ContentHash, HashId\n\ntop_hashes = [\n    TopHash(ContentHash(HashId(\"opaque\", f\"content_{i}\")), count=10 - i)\n    for i in range(5)\n]\n</code></pre>"},{"location":"sdk/hash_core/#serialization","title":"Serialization","text":"<p>Content hashes serialize to nested JSON:</p> <pre><code>{\n  \"hash\": {\n    \"id\": {\n      \"algo\": \"opaque\",\n      \"value\": \"h1\"\n    }\n  },\n  \"count\": 8\n}\n</code></pre>"},{"location":"sdk/hash_core/#related-types","title":"Related Types","text":"<ul> <li>WindowAgg - Contains lists of TopHash objects</li> <li>Digests - Content fingerprinting with similarity hashes</li> <li>I/O Schema - Serialization utilities</li> </ul>"},{"location":"sdk/hash_core/#database-storage","title":"Database Storage","text":"<p>Store <code>TopHash</code> inside JSON columns for flexibility: - Preserves algorithm and canonical value - Enables JSON extraction of fields for queries - Keeps counts alongside identifiers</p> <p>See Schema Reference for examples.</p>"},{"location":"sdk/ids/","title":"ID Management","text":"<p>ID management types provide consistent identifier schemes across the transparency simulation system.</p>"},{"location":"sdk/ids/#overview","title":"Overview","text":"<p>The ID management module defines standardized approaches for creating, validating, and using identifiers throughout the system. This ensures consistency and enables cross-referencing between different components.</p>"},{"location":"sdk/ids/#core-types","title":"Core Types","text":""},{"location":"sdk/ids/#hashid","title":"HashId","text":"<p>Basic hash identifier with type information.</p> <pre><code>@dataclass\nclass HashId:\n    type: str\n    value: str\n</code></pre> <p>Fields: - type: Hash algorithm or identifier type - value: The actual identifier string</p> <p>Common Types: - <code>\"opaque\"</code>: Synthetic identifiers for testing - <code>\"sha256\"</code>: SHA-256 cryptographic hashes - <code>\"md5\"</code>: MD5 hashes (legacy support) - <code>\"simhash\"</code>: SimHash signatures - <code>\"uuid\"</code>: UUID identifiers</p>"},{"location":"sdk/ids/#worldid","title":"WorldId","text":"<p>Identifier for simulation worlds.</p> <pre><code>@dataclass\nclass WorldId:\n    value: str\n\n    def __post_init__(self):\n        if not self.value:\n            raise ValueError(\"World ID cannot be empty\")\n</code></pre>"},{"location":"sdk/ids/#topicid","title":"TopicId","text":"<p>Identifier for content clusters without seeing content. A <code>TopicId</code> is a deterministic key derived from content identifiers/fingerprints (e.g., SimHash/MinHash via LSH).</p> <pre><code>from dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass TopicId:\n    algo: str   # e.g., \"simhash64-lsh\", \"minhash-lsh\", \"sha256\", \"opaque-topic\"\n    value: str  # canonical cluster key for that algo\n\n    def __str__(self) -&gt; str:\n        return f\"{self.algo}:{self.value}\"\n</code></pre> <p>Examples (strings stored in DB):</p> <ul> <li>simhash64-lsh:9f3a5c10aa55ee77</li> <li>minhash-lsh:AbC1_2xY... (base64url if not hex)</li> <li>opaque-topic:t_001</li> </ul> <p>Note: TopicId is not a human-readable label.  TopicId is a stable, privacy-preserving cluster key.</p>"},{"location":"sdk/ids/#usage-examples","title":"Usage Examples","text":""},{"location":"sdk/ids/#basic-identifiers","title":"Basic Identifiers","text":"<pre><code>from ci.transparency.sdk import HashId, WorldId, TopicId\n\n# Hash identifiers\ncontent_hash = HashId(\"sha256\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\")\nopaque_hash = HashId(\"opaque\", \"test_content_123\")\n\n# World and topic identifiers\nworld = WorldId(\"experiment_A\")\ntopic = TopicId(\"simhash64-lsh\")\n</code></pre>"},{"location":"sdk/ids/#identifier-validation","title":"Identifier Validation","text":"<pre><code>def validate_hash_id(hash_id: HashId) -&gt; bool:\n    \"\"\"Validate hash ID format.\"\"\"\n    if hash_id.type == \"sha256\":\n        return len(hash_id.value) == 64 and all(c in \"0123456789abcdef\" for c in hash_id.value.lower())\n    elif hash_id.type == \"md5\":\n        return len(hash_id.value) == 32 and all(c in \"0123456789abcdef\" for c in hash_id.value.lower())\n    elif hash_id.type == \"opaque\":\n        return bool(hash_id.value)  # Any non-empty string\n    return False\n</code></pre>"},{"location":"sdk/ids/#identifier-generation","title":"Identifier Generation","text":"<pre><code>import hashlib\nimport uuid\n\ndef generate_content_hash(content: str) -&gt; HashId:\n    \"\"\"Generate SHA-256 hash for content.\"\"\"\n    hash_value = hashlib.sha256(content.encode()).hexdigest()\n    return HashId(\"sha256\", hash_value)\n\ndef generate_world_id() -&gt; WorldId:\n    \"\"\"Generate unique world identifier.\"\"\"\n    return WorldId(f\"world_{uuid.uuid4().hex[:8]}\")\n</code></pre>"},{"location":"sdk/ids/#identifier-patterns","title":"Identifier Patterns","text":""},{"location":"sdk/ids/#hierarchical-naming","title":"Hierarchical Naming","text":"<pre><code># Use hierarchical patterns for organization\nexperiment_world = WorldId(\"exp2025_baseline_A\")\ntopic_cluster = TopicId(\"election2024_policy_discussion\")\n</code></pre>"},{"location":"sdk/ids/#timestamped-identifiers","title":"Timestamped Identifiers","text":"<pre><code>from datetime import datetime\n\ndef timestamped_world_id(prefix: str) -&gt; WorldId:\n    \"\"\"Create timestamped world identifier.\"\"\"\n    timestamp = datetime.utcnow().strftime(\"%Y%m%d_%H%M%S\")\n    return WorldId(f\"{prefix}_{timestamp}\")\n</code></pre>"},{"location":"sdk/ids/#content-based-identifiers","title":"Content-Based Identifiers","text":"<pre><code>def content_topic_id(content_sample: str) -&gt; TopicId:\n    \"\"\"Generate topic ID based on content characteristics.\"\"\"\n    # Simplified example - in practice would use NLP\n    keywords = content_sample.lower().split()[:3]\n    return TopicId(\"_\".join(keywords))\n</code></pre>"},{"location":"sdk/ids/#serialization","title":"Serialization","text":"<p>Identifiers serialize to simple string values or structured objects:</p> <pre><code>{\n  \"hash_id\": {\n    \"algo\": \"sha256\",\n    \"value\": \"e3b0c44298fc...\"\n  },\n  \"world_id\": \"experiment_A\",\n  \"topic_id\": \"9f3a5c10aa55ee77\"\n}\n</code></pre>"},{"location":"sdk/ids/#validation-utilities","title":"Validation Utilities","text":""},{"location":"sdk/ids/#format-checking","title":"Format Checking","text":"<pre><code>class IdValidator:\n    @staticmethod\n    def is_valid_world_id(world_id: str) -&gt; bool:\n        \"\"\"Check if world ID format is valid.\"\"\"\n        return bool(world_id and len(world_id) &lt;= 64 and world_id.replace(\"_\", \"\").replace(\"-\", \"\").isalnum())\n\n    @staticmethod\n    def is_valid_topic_id(topic_id: str) -&gt; bool:\n        \"\"\"Check if topic ID format is valid.\"\"\"\n        return bool(topic_id and len(topic_id) &lt;= 128)\n</code></pre>"},{"location":"sdk/ids/#uniqueness-checking","title":"Uniqueness Checking","text":"<pre><code>class IdRegistry:\n    def __init__(self):\n        self.used_world_ids = set()\n        self.used_topic_ids = set()\n\n    def register_world_id(self, world_id: WorldId) -&gt; bool:\n        \"\"\"Register world ID and check uniqueness.\"\"\"\n        if world_id.value in self.used_world_ids:\n            return False\n        self.used_world_ids.add(world_id.value)\n        return True\n</code></pre>"},{"location":"sdk/ids/#best-practices","title":"Best Practices","text":""},{"location":"sdk/ids/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use descriptive prefixes for different identifier types</li> <li>Include version numbers for evolving experiments</li> <li>Use consistent separators (underscores recommended)</li> <li>Avoid spaces and special characters</li> </ul>"},{"location":"sdk/ids/#collision-avoidance","title":"Collision Avoidance","text":"<ul> <li>Include timestamps for time-sensitive identifiers</li> <li>Use random components for high-uniqueness requirements</li> <li>Validate uniqueness before using identifiers</li> <li>Maintain registries for active identifier spaces</li> </ul>"},{"location":"sdk/ids/#documentation","title":"Documentation","text":"<ul> <li>Document identifier schemes in experiment metadata</li> <li>Include identifier generation rules in configuration</li> <li>Provide examples of valid identifiers</li> <li>Explain identifier meaning and scope</li> </ul>"},{"location":"sdk/ids/#related-types","title":"Related Types","text":"<ul> <li>ContentHash - Uses HashId for content identification</li> <li>WindowAgg - Uses world_id and topic_id fields</li> </ul>"},{"location":"sdk/ids/#database-storage","title":"Database Storage","text":"<p>Identifiers map to database columns: - Simple string storage for most identifier types - JSON storage preserves type information for HashId - Indexes on identifier columns for efficient queries</p> <p>See Schema Reference for database identifier handling.</p>"},{"location":"sdk/io_schema/","title":"I/O Schema","text":"<p>I/O schema types handle serialization, deserialization, and data format conversion for transparency simulation data.</p>"},{"location":"sdk/io_schema/#overview","title":"Overview","text":"<p>The I/O schema module provides functions and utilities for converting between internal Python objects and external formats (JSON, JSONL, database records). This enables data persistence, cross-platform compatibility, and integration with analysis tools.</p>"},{"location":"sdk/io_schema/#core-functions","title":"Core Functions","text":""},{"location":"sdk/io_schema/#json-serialization","title":"JSON Serialization","text":"<p>windowagg_to_json()</p> <pre><code>def windowagg_to_json(window: WindowAgg) -&gt; Dict[str, Any]:\n    \"\"\"Convert WindowAgg to JSON-serializable dictionary.\"\"\"\n</code></pre> <p>Converts a WindowAgg object to a dictionary suitable for JSON serialization. Handles: - Datetime objects \u2192 ISO timestamp strings - Complex nested objects \u2192 nested dictionaries - Optional fields \u2192 null values where appropriate</p> <p>windowagg_from_json()</p> <pre><code>def windowagg_from_json(data: Dict[str, Any]) -&gt; WindowAgg:\n    \"\"\"Convert JSON dictionary back to WindowAgg object.\"\"\"\n</code></pre> <p>Reconstructs a WindowAgg object from JSON data. Performs: - ISO timestamp parsing \u2192 datetime objects - Type validation and conversion - Optional field handling - Nested object reconstruction</p>"},{"location":"sdk/io_schema/#binary-serialization","title":"Binary Serialization","text":"<p>dumps()</p> <pre><code>def dumps(obj: Any) -&gt; bytes:\n    \"\"\"Serialize object to compact binary format.\"\"\"\n</code></pre> <p>Serializes objects to binary format using orjson for efficiency and compactness.</p> <p>loads()</p> <pre><code>def loads(data: bytes) -&gt; Any:\n    \"\"\"Deserialize binary data back to object.\"\"\"\n</code></pre> <p>Deserializes binary data back to Python objects.</p>"},{"location":"sdk/io_schema/#usage-examples","title":"Usage Examples","text":""},{"location":"sdk/io_schema/#basic-serialization","title":"Basic Serialization","text":"<pre><code>from ci.transparency.sdk import WindowAgg, windowagg_to_json, windowagg_from_json, dumps, loads\n\n# Create window data\nwindow = WindowAgg(...)\n\n# Convert to JSON\njson_data = windowagg_to_json(window)\n\n# Serialize to binary\nbinary_data = dumps(json_data)\n\n# Round-trip conversion\nrestored_json = loads(binary_data)\nrestored_window = windowagg_from_json(restored_json)\n\nassert window == restored_window\n</code></pre>"},{"location":"sdk/io_schema/#jsonl-file-operations","title":"JSONL File Operations","text":"<pre><code>def write_windows_jsonl(windows: List[WindowAgg], filepath: str):\n    \"\"\"Write windows to JSONL file.\"\"\"\n    with open(filepath, 'wb') as f:\n        for window in windows:\n            json_data = windowagg_to_json(window)\n            f.write(dumps(json_data))\n            f.write(b'\\n')\n\ndef read_windows_jsonl(filepath: str) -&gt; List[WindowAgg]:\n    \"\"\"Read windows from JSONL file.\"\"\"\n    windows = []\n    with open(filepath, 'rb') as f:\n        for line in f:\n            if line.strip():\n                json_data = loads(line.strip())\n                windows.append(windowagg_from_json(json_data))\n    return windows\n</code></pre>"},{"location":"sdk/io_schema/#database-integration","title":"Database Integration","text":"<pre><code>def window_to_db_params(window: WindowAgg) -&gt; tuple:\n    \"\"\"Convert WindowAgg to database parameters.\"\"\"\n    json_data = windowagg_to_json(window)\n\n    return (\n        json_data['world_id'],\n        json_data['topic_id'],\n        datetime.fromisoformat(json_data['window_start']),\n        datetime.fromisoformat(json_data['window_end']),\n        json_data['n_messages'],\n        json_data['n_unique_hashes'],\n        json_data['dup_rate'],\n        dumps(json_data['top_hashes']),  # Store as binary JSON\n        json_data['hash_concentration'],\n        json_data['burst_score'],\n        json_data['type_mix']['post'],\n        json_data['type_mix']['reply'],\n        json_data['type_mix']['retweet'],\n        dumps(json_data['time_histogram'])\n    )\n</code></pre>"},{"location":"sdk/io_schema/#json-schema","title":"JSON Schema","text":""},{"location":"sdk/io_schema/#windowagg-json-format","title":"WindowAgg JSON Format","text":"<pre><code>{\n  \"world_id\": \"A\",\n  \"topic_id\": \"baseline\",\n  \"window_start\": \"2025-09-10T14:00:00Z\",\n  \"window_end\": \"2025-09-10T14:10:00Z\",\n  \"n_messages\": 214,\n  \"n_unique_hashes\": 183,\n  \"dup_rate\": 0.14485981308411214,\n  \"top_hashes\": [\n    {\n      \"hash\": {\n        \"id\": {\n          \"algo\": \"opaque\",\n          \"value\": \"h1\"\n        }\n      },\n      \"count\": 8\n    }\n  ],\n  \"hash_concentration\": 0.15,\n  \"burst_score\": 0.8,\n  \"type_mix\": {\n    \"post\": 0.51,\n    \"reply\": 0.32,\n    \"retweet\": 0.17\n  },\n  \"time_histogram\": [12, 9, 7, 5, 3, 2, 1, 0, 0, 0],\n  \"digests\": {\n    \"simhash64\": {\n      \"bits\": \"0x9F3A5C10AA55EE77\"\n    },\n    \"minhash\": {\n      \"k\": 4,\n      \"sig\": [1, 2, 3, 4]\n    }\n  }\n}\n</code></pre>"},{"location":"sdk/io_schema/#error-handling","title":"Error Handling","text":""},{"location":"sdk/io_schema/#validation","title":"Validation","text":"<pre><code>def validate_json_schema(data: Dict[str, Any]) -&gt; List[str]:\n    \"\"\"Validate JSON data against expected schema.\"\"\"\n    errors = []\n\n    required_fields = ['world_id', 'topic_id', 'window_start', 'window_end']\n    for field in required_fields:\n        if field not in data:\n            errors.append(f\"Missing required field: {field}\")\n\n    # Type validation\n    if 'dup_rate' in data and not isinstance(data['dup_rate'], (int, float)):\n        errors.append(\"dup_rate must be numeric\")\n\n    return errors\n</code></pre>"},{"location":"sdk/io_schema/#error-recovery","title":"Error Recovery","text":"<pre><code>def safe_windowagg_from_json(data: Dict[str, Any]) -&gt; Optional[WindowAgg]:\n    \"\"\"Safely convert JSON to WindowAgg with error handling.\"\"\"\n    try:\n        return windowagg_from_json(data)\n    except (KeyError, ValueError, TypeError) as e:\n        logger.warning(f\"Failed to parse WindowAgg: {e}\")\n        return None\n</code></pre>"},{"location":"sdk/io_schema/#performance-considerations","title":"Performance Considerations","text":""},{"location":"sdk/io_schema/#memory-efficiency","title":"Memory Efficiency","text":"<ul> <li>Use streaming for large datasets</li> <li>Process JSONL files line by line</li> <li>Avoid loading entire datasets into memory</li> </ul>"},{"location":"sdk/io_schema/#speed-optimization","title":"Speed Optimization","text":"<ul> <li>orjson provides faster JSON serialization than standard library</li> <li>Binary format reduces file size and I/O time</li> <li>Batch database operations for better performance</li> </ul>"},{"location":"sdk/io_schema/#compatibility","title":"Compatibility","text":"<p>-</p>"},{"location":"sdk/overview/","title":"Type Reference Overview","text":"<p>The civic transparency simulation core provides a structured type system for representing temporal activity patterns, content fingerprints, and aggregated metrics. This type system enables reproducible research and standardized analysis across different transparency studies.</p>"},{"location":"sdk/overview/#core-concepts","title":"Core Concepts","text":""},{"location":"sdk/overview/#window-aggregation","title":"Window Aggregation","text":"<p>The fundamental unit of analysis is a time window containing aggregated activity data. Each window represents a slice of time (typically 10-15 minutes) with calculated metrics and content fingerprints.</p>"},{"location":"sdk/overview/#content-clustering","title":"Content Clustering","text":"<p>Content is identified through hash-based clustering. Similar content gets grouped under topic identifiers, enabling analysis of how specific topics or themes spread through systems.</p>"},{"location":"sdk/overview/#fingerprinting","title":"Fingerprinting","text":"<p>Content fingerprints use multiple techniques: - SimHash: Locality-sensitive hashing for near-duplicate detection - MinHash: Set similarity estimation for clustering analysis</p>"},{"location":"sdk/overview/#temporal-patterns","title":"Temporal Patterns","text":"<p>Activity patterns are captured through: - Time-series data within windows - Cross-window trend analysis - Burst detection and anomaly scoring</p>"},{"location":"sdk/overview/#type-categories","title":"Type Categories","text":""},{"location":"sdk/overview/#core-types","title":"Core Types","text":"<p>Essential data structures for window-based analysis:</p> <ul> <li>WindowAgg: Complete window aggregation with all metrics</li> <li>ContentHash: Hash-based content identification</li> <li>Digests: Content fingerprinting data structures</li> </ul>"},{"location":"sdk/overview/#configuration-types","title":"Configuration Types","text":"<p>Control structures for generation and analysis:</p> <ul> <li>EventConfig: Configuration for temporal events and scenarios</li> </ul>"},{"location":"sdk/overview/#utility-types","title":"Utility Types","text":"<p>Supporting structures for data handling:</p> <ul> <li>ID Management: Consistent identifier schemes</li> <li>I/O Schema: Serialization and database integration</li> <li>Registry: Type registration and discovery</li> </ul>"},{"location":"sdk/overview/#design-principles","title":"Design Principles","text":"<p>Immutability: Core data structures are immutable to ensure consistency across analysis pipelines.</p> <p>Composability: Types can be combined and extended for different research scenarios.</p> <p>Serialization: All types support JSON serialization for cross-platform compatibility.</p> <p>Validation: Built-in validation ensures data integrity throughout the analysis pipeline.</p> <p>Documentation: Comprehensive docstrings and type hints support IDE integration and static analysis.</p>"},{"location":"sdk/overview/#import-patterns","title":"Import Patterns","text":"<pre><code># Core analysis types\nfrom ci.transparency.sdk import WindowAgg, ContentHash, TopHash\n\n# Content fingerprinting\nfrom ci.transparency.sdk import Digests, SimHash64, MinHashSig\n\n# I/O and serialization\nfrom ci.transparency.sdk import windowagg_to_json, windowagg_from_json\n\n# Utility functions\nfrom ci.transparency.sim.metrics import herfindahl, cv_of_bins\n</code></pre>"},{"location":"sdk/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Window Aggregation - Core analysis data structure</li> <li>Content Hashing - Content identification and clustering</li> <li>I/O Schema - Serialization and database integration</li> </ul>"},{"location":"sdk/window_agg/","title":"Window Aggregation","text":"<p>The <code>WindowAgg</code> type represents a time window of aggregated activity data. This is the primary data structure for temporal analysis of content patterns.</p>"},{"location":"sdk/window_agg/#overview","title":"Overview","text":"<p>A window aggregation captures all relevant metrics for a specific time period, typically 10-15 minutes. It includes activity counts, content clustering data, temporal patterns, and content fingerprints.</p>"},{"location":"sdk/window_agg/#type-definition","title":"Type Definition","text":"<pre><code>@dataclass\nclass WindowAgg:\n    world_id: str\n    topic_id: str\n    window_start: datetime\n    window_end: datetime\n    n_messages: int\n    n_unique_hashes: int\n    dup_rate: float\n    top_hashes: List[TopHash]\n    hash_concentration: float\n    burst_score: float\n    type_mix: Dict[str, float]\n    time_histogram: List[int]\n    digests: Optional[Digests] = None\n</code></pre>"},{"location":"sdk/window_agg/#fields","title":"Fields","text":""},{"location":"sdk/window_agg/#identifiers","title":"Identifiers","text":"<ul> <li>world_id: Identifier for the simulation world (e.g., \"A\", \"B\")</li> <li>topic_id: Topic cluster identifier for content grouping</li> </ul>"},{"location":"sdk/window_agg/#temporal","title":"Temporal","text":"<ul> <li>window_start: Start timestamp of the aggregation window</li> <li>window_end: End timestamp of the aggregation window</li> </ul>"},{"location":"sdk/window_agg/#activity-metrics","title":"Activity Metrics","text":"<ul> <li>n_messages: Total number of messages in the window</li> <li>n_unique_hashes: Number of distinct content hashes</li> <li>dup_rate: Duplication rate (1.0 - unique_rate), range [0.0, 1.0]</li> </ul>"},{"location":"sdk/window_agg/#content-clustering","title":"Content Clustering","text":"<ul> <li>top_hashes: List of most frequent content clusters with counts</li> <li>hash_concentration: Herfindahl index measuring content concentration</li> </ul>"},{"location":"sdk/window_agg/#temporal-patterns","title":"Temporal Patterns","text":"<ul> <li>burst_score: Coefficient of variation for minute-level activity</li> <li>time_histogram: Message counts for each minute in the window</li> </ul>"},{"location":"sdk/window_agg/#content-analysis","title":"Content Analysis","text":"<ul> <li>type_mix: Proportions of content types (post/reply/retweet)</li> <li>digests: Optional content fingerprints (SimHash, MinHash)</li> </ul>"},{"location":"sdk/window_agg/#usage-examples","title":"Usage Examples","text":""},{"location":"sdk/window_agg/#creating-a-windowagg","title":"Creating a WindowAgg","text":"<pre><code>from datetime import datetime, timedelta\nfrom ci.transparency.sdk import WindowAgg, TopHash, ContentHash, HashId\n\nstart = datetime(2025, 9, 10, 14, 0, 0)\nend = start + timedelta(minutes=10)\n\nwindow = WindowAgg(\n    world_id=\"A\",\n    topic_id=\"baseline\",\n    window_start=start,\n    window_end=end,\n    n_messages=214,\n    n_unique_hashes=183,\n    dup_rate=1 - 183 / 214,\n    top_hashes=[\n        TopHash(ContentHash(HashId(\"opaque\", \"h1\")), count=8),\n        TopHash(ContentHash(HashId(\"opaque\", \"h2\")), count=6),\n    ],\n    hash_concentration=0.15,\n    burst_score=0.8,\n    type_mix={\"post\": 0.51, \"reply\": 0.32, \"retweet\": 0.17},\n    time_histogram=[12, 9, 7, 5, 3, 2, 1, 0, 0, 0],\n)\n</code></pre>"},{"location":"sdk/window_agg/#serialization","title":"Serialization","text":"<pre><code>from ci.transparency.sdk import windowagg_to_json, windowagg_from_json\n\n# Convert to JSON-serializable dict\njson_data = windowagg_to_json(window)\n\n# Convert back to WindowAgg\nrestored = windowagg_from_json(json_data)\n</code></pre>"},{"location":"sdk/window_agg/#metrics-calculation","title":"Metrics Calculation","text":"<pre><code>from ci.transparency.sim.metrics import herfindahl, cv_of_bins\n\n# Calculate hash concentration\nhhi = herfindahl([hash.count for hash in window.top_hashes])\n\n# Calculate burst score from time series\nburst = cv_of_bins(window.time_histogram)\n</code></pre>"},{"location":"sdk/window_agg/#design-considerations","title":"Design Considerations","text":""},{"location":"sdk/window_agg/#immutability","title":"Immutability","text":"<p>WindowAgg instances are immutable to ensure consistency across analysis pipelines. Create new instances for modifications.</p>"},{"location":"sdk/window_agg/#time-resolution","title":"Time Resolution","text":"<p>Windows typically span 10-15 minutes with minute-level granularity in the time histogram. This balance captures burst patterns without excessive noise.</p>"},{"location":"sdk/window_agg/#content-representation","title":"Content Representation","text":"<p>Content is represented through hashes rather than actual text to maintain privacy and enable cross-platform analysis.</p>"},{"location":"sdk/window_agg/#optional-fields","title":"Optional Fields","text":"<p>The <code>digests</code> field is optional to support scenarios where content fingerprinting is not needed or available.</p>"},{"location":"sdk/window_agg/#related-types","title":"Related Types","text":"<ul> <li>TopHash - Individual content cluster data</li> <li>Digests - Content fingerprinting data</li> <li>ContentHash - Content identification</li> </ul>"},{"location":"sdk/window_agg/#database-storage","title":"Database Storage","text":"<p>WindowAgg data maps to the <code>events</code> table in DuckDB: - JSON serialization for complex fields (top_hashes, time_histogram) - Proper timestamp handling for temporal fields - Separate columns for scalar metrics</p> <p>See Schema Reference for complete database mapping details.</p>"}]}